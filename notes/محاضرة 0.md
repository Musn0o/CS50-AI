##  الذكاء الاصطناعي
---

الذكاء الاصطناعي يشمل عدة تقنيات التي التي تحاكي السلوك الذكي على سبيل المثال يمكن للذكاء الاصطناعي انا يحدد الوجوه بالصور على وسائل التواصل الاجتماعي والتغلب على بطل العالم في الشطرنج ومعالجة كلامك عندما تتحدث الى  (Siri) او (Alexa) على هاتفك

في هذا الكورس سنقوم بدراسة بعض الافكار التي تجعل الذكاء الاصطناعي ممكناَ:

0. **البحث (Search)**

إيجاد حل لمشكلة مثل تطبيق الخريطة او التوصيل الذي يقوم بالبحث عن أفضل طريق من مكانك الى الوجهة أو مثل لعب لعبة والقدرة على تحديد الخطوة التالية.

1. **المعرفة (Knowledge)**

تقديم المعلومات بطريقة نستطيع إستخراج إستدلالات منها.

2. **عدم التأكد (Uncertainty)**

التعامل مع الاحداث الغير مؤكدة باستخدام الاحتمالات.

3. **التحسين (Optimization)**

عدم الاكتفاء بالعثور على طريقة واحدة في حل مشكلة بل الأحسن أو أفضل طريقة حل ممكنة

4. **التعلم (Learning)**

تطوير الأداء عن طريق الحصول على بيانات و خبرات على سبيل المثال البريد الإلكتروني الخاص بك يمكنه تحديد الرسائل الزائفة من الحقيقية بناءاََ على الخبرات السابقة.

5. **الشبكات العصبية (Neural Networks)**

بنية البرنامج مستوحاة من العقل البشري ليستطيع القيام بالمهام بشكل فعال.

6. **اللغة (Language)**

معالجة وفهم اللغة الطبيعية (البشرية) التي ينتجها ويفهمها البشر


## البحث (Search)
---
تتضمن **مشكلات البحث** عاملاً (أو وكيلاً) يُعطى حالة أولية وحالة هدف، ويُرجع هذا الوكيل حلاً يوضح كيفية الانتقال من الحالة الأولى إلى الحالة الثانية (الهدف). تستخدم **تطبيقات الملاحة والتوصيل** عملية بحث نموذجية، حيث يستقبل الوكيل (الجزء المسؤول عن التفكير في البرنامج) موقعك الحالي والوجهة المطلوبة كمدخلات، وبناءً على **خوارزمية بحث**، يُرجع مساراً مقترحاً. ومع ذلك، هناك أشكال عديدة أخرى لمشكلات البحث، مثل الألغاز والمتاهات.

**بالمصري الدارج كده، الموضوع عامل زي لما تكون رايح تزور قرايبك في مكان عمرك ما روحتوا قبل كده. أنت عارف أنت فين دلوقتي (حالة البداية) وعارف عايز تروح فين (حالة الهدف). المهمة بقى إنك تلاقي أسهل طريق أو أسرع طريق يوصلك هناك. ده بالظبط اللي الـ"بحث" بيحاول يعمله في عالم الذكاء الاصطناعي!**

![15 puzzle](https://cs50.harvard.edu/ai/notes/0/15puzzle.png)

إيجاد حل للغز مكون من 15 قطعة سيتطلب إستخدام خوارزمية البحث

- **الوكيل (Agent)**

هو كيان **يدرك** بيئته **و يتصرف بناءً عليها**. في تطبيق الملاحة على سبيل المثال سوف يمثل الوكيل سيارة تحتاج الى اختيار التحركات المطلوب اتخاذها للوصول للهدف المراد.

-  **الحالة (State)**

هي وضع او موقع الوكيل في البيئة الخاصة به على سبيل المثال في اللغز المكون من 15 قطعة الحالة تمثل الشكل الذي ترى به ترتيب القطع بشكل معين عند تحريك قطعة واحدة يتم التغيير الى **حالة جديدة**

-  **الحالة الأولية (Initial State)**

الحالة التي تبدأ خوارزمية البحث عندها في برنامج الملاحة سيكون هذا مكانك الحالي.

-  **التحركات (Actions)**

الخيارات التي يمكن اتخاذها في حالة معينة بتعبير أدق يمكن معاملتها **كدالة (function)** تأخذ معطيات و تمنحك نتائج عندما تقوم بأخذ الحالة `s` كمعطى `Actions(s)` تمنحك مجموعة من التحركات التي يمكن اتخاذها في الحالة التي نقف بها `s` . على سبيل المثال في اللغز المكون من 15 قطعة الخيارات المتاحة للحالة تكون الطرق التي يمكنك تحريك القطع حسب الشكل الحالي (4 اذا كان الفراغ بالمنتصف, 3 اذا كان بالجانب او 2 اذا كان بالكورنر)

-  **نموذج الانتقال (Transition Model)**

وصف لشكل الحالة الذي سينتج من اتخاذ اي خيار ملائم في أي حالة. بتعبير أدق يمكن اعتبارها **كدالة (function)** عندما تأخذ الحالة `s` و الخيار  `a` كمعطيات يكون  `النتائج (s, a)` هذه هي الحالة الناتجة من اتخاذ الخيار `a` مع الحالة `s` .  على سبيل المثال في اللغز المكون من 15 قطعة الهيكل الحالي (الحالة `s`) اذا قمت بتحريك قطعة الى أي اتجاه (الحركة `a`) ستصل الى شكل جديد من اللغز (حالة جديدة)

-  **نطاق الحالات**

هو مجموعة الحالات الممكنة التي يمكن الوصول إليها انطلاقًا من الحالة الابتدائية من خلال أي تسلسل من الأختيارات. فعلى سبيل المثال، في لغز 15، يتكوّن نطاق الحالات من جميع الترتيبات الممكنة على اللوحة والبالغ عددها ‎16!⁄2‎، والتي يمكن الوصول إليها من أي حالة ابتدائية. يمكن تصوّر نطاق الحالات كأنه رسم بياني موجه، تمثّل فيه الحالات كمحطات، والاختيارات كطرق تصل بين المحطات.

**ملاحظة:**  
العدد ‎16!⁄2‎ يمثل جميع الترتيبات الممكنة لقطع لغز 15 (بما في ذلك الفراغ) التي يمكن الوصول إليها فعليًا من خلال تحريك القطع. رغم أن هناك ‎16!‎ ترتيبًا إجماليًا، فإن نصفها فقط يمكن حله بسبب قيود رياضية تتعلق بطريقة حركة القطع، لذلك نقسم على 2.


![State Space](https://cs50.harvard.edu/ai/notes/0/statespace.png)

-  **اختبار الهدف (Goal Test)**

هي الطريقة التي تحدد اذا كانت الحالة المعطاة هي الهدف او لا. على سبيل المثال في ابليكيشن التوصيل اختبار الهدف سيكون اما الموقع الحالي للوكيل (السيارة) في المكان المراد الوصول اليه ويكون تم حل المشكلة او تستمر عملية البحث.

-  **تكلفة الطريق (Path Cost)**

التكلفة المرتبطة بكل طريق من الممكن ان تأخذه. على سبيل المثال ابليكيشن التوصيل يقوم بحساب اقصر طريق بحيث يكون غير مكلف وولإيجاد أسرع طريق ممكن للوصول إلى الهدف

## حل مشكلات البحث
---

-  **الحل (Solution)**

هو تسلسل من الاختيارات التي تنقلنا من الحالة الأولية إلى الحالة الهدف.

يعني لو الجو حر عندك زيي **الحل** غالباََ انك تشوف عربية توصلك من بيتك للبحر.

-  **الحل الأمثل (Optimal Solution)**

هو الحل ذو التكلفة الأقل من بين جميع الحلول الممكنة (غير مكلف من ناحية المسافة)


في عملية البحث يتم تخزين البيانات غالباََ في **المحطة (node)** وهو يحتوي على البيانات التالية:

- حالة
- المحطة السابقة (الأم) المتسببة في وجود المحطة الحالية
- الخيار الذي تم تطبيقة على الأم للوصول للمحطة الحالية
- التكلفة من الحالة الأولية الى المحطة الحالية
---
**ملاحظة:**

المصطلح العلمي الشائع ل **(node)** هو **عقدة** ولكن انا لا أهتم للمصطلحات العلمية المعقدة الي يهمني هو ايصال المعلومة و أفضل استخدام **المحطة** لتبسيط الأمور لأنها مفهومه أكثر عندما نتحدث عن البحث عن مكان او شئ في العموم لكن" **عقدة؟**" احنا مش جايين نسوق سفينة ولا جايين نحط العقدة في المنشار هدفي ان انا اخلي الكلام بسيط ومفهوم لكل الناس بقدر الإمكان.

---
المحطات تحتوي على معلومات التي تجعلها مهمه جدا في خوارزمية البحث. المحطات تحتوي على **الحالة** التي يمكن فحصها عن طريق عمل **اختبار للهدف (goal test)** لمعرفة اذا كانت هي اخر حالة نريد الوصول اليها. اذا كانت هي الحالة المراده يتم حساب تكلفة الطريق لنقطة للمحطة الحالية لمقارنتها بالمحطات الأخرى. وهذا سيساعدنا في اختيار **الحل الأمثل (Optimal Solution)**. عند اختيار محطة معينة بفضل تخزين **المحطة السابقة (الأم)** و **الخيار (action)** الذي تم اتخاذه من الأم للمحطة الحالية من الممكن العودة الى الخلف خطوة بخطوة حتى **حالة البداية (initial state)** وهذا التسلسل من الخيارات هو **الحل (solution)**

و مع ذلك المحطات ببساطة هيكل من البيانات لا تقوم بالبحث وانما تحتفظ بالمعلومات. لنقوم بالبحث الفعلي نقوم بإستخدام **السائق (the frontier)** وهو المسئول عن إدارة المحطات. عند بداية عمل السائق يكون لدية الحالة الأولى و **مجموعة المحطات المستكشفة (set of explored items)** وسيقوم بتكرار الاختيارات التالية حتى يصل الى **الحل**.

تكرار:

1. اذا كان السائق ليس لدية أي طرق أخرى ليستكشفها
	
	-  توقف لا يوجد طريقة حل للمشكلة

2. تقوم بإزالة محطة من قائمة السائق وهذه المحطة سيتم اخذها بالإعتبار

3. اذا كانت المحطة تحتوي على الحالة المراد الوصول اليها

	-  هذا هو الحل توقف
	او
	- قم بالتوسع عن طريق (إيجاد كل المحطات الجديدة التي يمكن الوصول إليها من المحطة الحالية), وقم بإضافة المحطات الناتجة الى قائمة السائق
	-  قم بإضافة المحطة الحالية  ل **مجموعة المحطات المستكشفة (set of explored items)** 

---
**ملاحظة:**

انا عارف طبعاََ ان **(the frontier)** معناها الصحيح **(الحدود)** ولو بشكل علمي ممكن يكون **(حدود البحث)** بس مش ناقصة تعقيدات والله الجو حر ومش مستحملة مصطلحات مجعلصة خلي الدنيا ايزي و
**(سواق)** هيوصلك من هنا لهنا وخلصت يعني مغلطناش ف البخاري

---

فكك بقى من الكلام دا وخليك معايا انا عاوز اروح البحر كل يوم لأن الجو حر فيه. 3 شواطئ معروفة بس مش عارف ايه أقرب واحد ليا انا في **محرم بك نقطة البداية (initial state)** و **هدفي هو الشاطئ (goal state)**  انا هركب تاكسي واقول **للسواق (the frontier)** انهاردا نطلع على أول شاطئ وقبل ما أوصل الشاطئ اشوف **المحطة (node)** الى قبله علشان اقدر احدد مسافتها من  **محرم بك نقطة البداية** و **السواق** هيكرر معايا نفس السيناريو بشكل يومي لحد ما نوصل لأقرب شاطئ.

طيب افرض **السواق (frontier)** على الله حكايته وميعرفش الطريق؟ هنضطر نستكشف بقى **المحطات (nodes)** كلها يا معلم مع **السواق (frontier)** دا ورزقي ورزقك ع الله كل لما نروح **محطة (node)** اقوله ها وصلنا؟ لا لسا ها وصلنا؟  لا لسا ممكن يخلص **المحطات (nodes)** كلها ومنوصلش اصلاََ بس كل لما نعدي **محطة (node)** لازم يسجلها ف **المحطات الى عدينا عليها (explored set)** علشان منرجعلهاش تاني وممكن ربنا يكرم ونوصل واقوله بس بس نزلني هنا يا الي منك لله واشوف بقى **المحطة الى فيها الشاطئ دي (solution)** بعيده عن **بيتي (initial state)** قد ايه.

## البحث العميق أولاََ (Depth-First Search)

في الوصف السابق **للسائق(the  frontier)** هناك شئ لم يتم ذكره. ف المرحلة الثانية, أي محطة يجب ان يتم ازالتها؟ هذا الاختيار ليه تأثير قوي على دقة **الحل** و سرعة الوصول إليه. هناك العديد من الطرق للتعامل مع مسألة المحطة التي يجب أخذها في الاعتبار أولاََ.  اثنتان منهما يمكن تمثيلهما من خلال هياكل البيانات  **الكُومة(stack)** البحث العميق اولاََ (Depth-First Search) و **الصف (queue)** البحث بالعرض اولاََ  (_breadth-first search_)  [وهذا رسم كرتوني لطيف يعرض الفرق بين الأثنين](https://www.youtube.com/watch?v=2wM6_PuBIxY)


سنبدأ بنهج البحث العميق أولاََ (_DFS_).

خوارزمية البحث العميق أولاََ تستنفد كل طريق على حدى قبل محاولة اتخاذ طريق مختلف في هذه الحالات يتم التعامل مع **السائق** على أنه **كُومة (stack)** من البيانات. العبارة التي يجب انا تتذكرها هنا **"أخر الواصلين هيكون أول الخارجين (last-in first-out)"** بعد اضافة المحطات الى السائق أول محطة يتم إزالتها وأخذها بالإعتبار هي أخر محطة سيتم إضافتها. هذا سيسبب خوارزمية بحث تأخذ أول طريق يقابلها إلى أقصى عمق ممكن بينما تترك باقي الأتجاهات الأخرى لاحقاََ

(مثال من خارج المحاضرة: تخيل انك تبحث عن مفاتيحك بطريقة **البحث العميق اولاََ** لو قمت بإختيار البحث في بنطالك هتقوم بالبحث في كل جيب على حدى وتقوم بإخلاء كل جيب والبحث بشكل دقيق ستقوم بإيقاف البحث في بنطالك والبحث في مكان أخر فقط عندما تقوم بفحص جميع الجيوب)

- المميزات:

	-  في أفضل الأحوال هذه الخوارزمية هي الأسرع إذا حالفها الحظ واختارت المسار الصحيح للحل (بالصدفة) في هذه الحالة طريقة البحث العميق أولاََ تأخذ أقل وقت للوصول إلى الحل.

- العيوب:

	-  من الممكن أن تكون طريقة الحل التي تصل اليها ليست الأفضل
	- في أسوء الأحوال ستقوم هذه الخوارزمية بفحص كل الطرق الممكنة قبل الوصول إلى الحل وهذا سيؤدي إلى أخذ أطول وقت ممكن قبل الوصول للحل.

مثال بالكود: 

```Python
#دي الاداة الى هنستخدمها علشان نشيل من قايمة السواق ونرجعها
def remove(self):
#تقوم بإلغاء البحث اذا كان السائق ليس لديه أي اتجاهات متاحة ليأخذها هذا يعني أنه ليس هناك حل
	if self.empty():
		raise Exception("empty frontier")
	else:

    # حفظ أخر محطة بالقائمة (أخر محطة تم اضافتها)
		node = self.frontier[-1]

# حفظ كل المحطات في القائمة باستثناء المحطة الأخيرة (أي إزالة المحطة الأخيرة)

		self.frontier = self.frontier[:-1]
		return node
```
#### [Depth-First Search](https://cs50.harvard.edu/ai/notes/0/#depth-first-search)

In the previous description of the _frontier_, one thing went unmentioned. At stage 2 in the pseudocode above, which node should be removed? This choice has implications on the quality of the solution and how fast it is achieved. There are multiple ways to go about the question of which nodes should be considered first, two of which can be represented by the data structures of **stack** (in _depth-first_ search) and **queue** (in _breadth-first search_; and [here is a cute cartoon demonstration](https://www.youtube.com/watch?v=2wM6_PuBIxY) of the difference between the two).

We start with the _depth-first_ search (_DFS_) approach.

A _depth-first_ search algorithm exhausts each one direction before trying another direction. In these cases, the frontier is managed as a _stack_ data structure. The catchphrase you need to remember here is “_last-in first-out_.” After nodes are being added to the frontier, the first node to remove and consider is the last one to be added. This results in a search algorithm that goes as deep as possible in the first direction that gets in its way while leaving all other directions for later.

(An example from outside lecture: Take a situation where you are looking for your keys. In a _depth-first_ search approach, if you choose to start with searching in your pants, you’d first go through every single pocket, emptying each pocket and going through the contents carefully. You will stop searching in your pants and start searching elsewhere only once you will have completely exhausted the search in every single pocket of your pants.)

- Pros:
    - At best, this algorithm is the fastest. If it “lucks out” and always chooses the right path to the solution (by chance), then _depth-first_ search takes the least possible time to get to a solution.
- Cons:
    - It is possible that the found solution is not optimal.
    - At worst, this algorithm will explore every possible path before finding the solution, thus taking the longest possible time before reaching the solution.

Code example:

```Python

# Define the function that removes a node from the frontier and returns it.
def remove(self):
  # Terminate the search if the frontier is empty, because this means that there is no solution.
	if self.empty():
		raise Exception("empty frontier")
	else:
  # Save the last item in the list (which is the newest node added)
		node = self.frontier[-1]
# Save all the items on the list besides the last node (i.e. removing the last node)
		self.frontier = self.frontier[:-1]
		return node
```